Let me explain the big picture, how the CAPOEP (which stands for Community Attested Proof of Education Protocol) Dapp would work is that anyone can create a CAPOEP "listing" which is a form that would take in details such as the education category(examples include learning, teaching, mentoring, internship, edu content creation, participation, edu event creation/management, and other things within education), title, details, and the listings proofs(this includes proof uploads which would be a URI link and external links that the lister presents to back up the truth to their listing). Then this listing is created on-chain and is shown in the dapp. After that, anyone can vote to Attest or Refute the listing which includes its education-category, title, details, and accompanying proofs by voting "Attest" or "Refute" which stands for agree or disagree with the listing and its proofs as a whole. Basically, people would be attesting to the truth or legitimacy of the listing as a whole which includes its: education-category, title, details, and proofs. A listing cannot be voted on by its lister meaning the same person who created a listing cannot vote on their own created listing. A "listing" needs to get at least 2 "attest" votes for the listing to be able to be mintable by the lister. So the listing would have a 2 attest votes threshold to be able to be minted as a CAPOEP nft by the lister, and to clarify the lister has to click the mint button to mint it, it does not automatically get minted and only the listing creator can mint its CAPOEP NFT. And another thing is once a listing has been minted as a CAPOEP nft I want the nft to be burnable, in case a user doesn't want it anymore or they think it's outdated or for any reason the user who owns the CAPOEP NFT wants to burn it.

On top of that, when people vote whether it be Attest or Refute, they are also required to provide a comment along with their vote to explain why they voted to Attest or Refute a listing, we will call this "Vote-Comments". Hence, they have to choose to vote to attest or refute a listing and they also have to explain their reason for their vote using a Vote-Comment along with their cast vote. The "Vote-Comments" work like the Reddit-style commenting system wherein each "Vote-Comment" can also be commented upon and each Vote-Comment can be upvoted or downvoted. The reason for this is for people to respond to each Vote-Comment and express their opinion of whether they agree or disagree with each voter's vote and its Vote-Comment by commenting under it and upvoting or downvoting it. For clarity's sake, a Vote-Comment can only be created when a user cast their Attest or Refute vote on a listing and both the vote and Vote-Comment are collected and recorded in tandem in the smart contract. And as I explained where Vote-Comments can only be created when a vote is cast, Vote-Comment's nested comments however are open to anyone to comment and Vote-Comments are also open for anyone to upvote or downvote on.

Apart from Vote-Comments, there should also be a Reddit-style commenting system for each listing called "Comments". "Comments" are essentially general comments akin to comments underneath a Reddit post, so people can discuss, give feedback, and ask questions about each listing.

To make things easier for you to understand and to paint a picture of the Dapp for you, you can take the perspective of Listings being presented like Reddit-Posts but instead of 1 commenting system there would be 2 types of commenting system which include Vote-Comments and Comments, imagine if you will a Reddit post having 2 tabs underneath it and 1 tab is Comments and another tab is Vote-Comments, and users can check out comments in both tabs, this makes separating the comments types much more better and easier for users to navigate. Both types of comments will have nested comments and a upvote and downvote mechanism to them however where in Comments anyone can post a comment, in Vote-Comments however only comments that are attached to votes are shown but like Comments they are also nestable comments so people can comment under and upvote and downvote Vote-Comments.

Next, the Dapp would also have a simple reputation point system kind of like the Reddit Karma point system. It works simply by giving + 1 point to users that receive an upvote on their Comment, Vote-Comment, and an Attest vote on their created listing. And giving - 1 point to users that receive an downvote on the Comment, Vote-Comment, and an Refute vote on their created listing, To make things clearer what I'm saying is if a user's Comment gets an upvote then its + 1 point for them, if a user's Vote-Comment gets an upvote then its + 1 point for them, and if a user's listing gets an Attest vote then its + 1 point for them on their reputation points. It's the same for point deduction where if a user's Comment gets a downvote then it's - 1 point for them, if a user's Vote-Comment gets an downvote then its - 1 point for them, and if a user's listing gets a Refute vote then it's - 1 point for them on their reputation points.

Ok now that we have that covered, next, I want to explain that Reputation Points can go below 0 and into the negative category meaning if a user that has a Reputation Point score of 15 receives 20 negative points meaning - 10 points then their Reputation Point score would be -5(negative 5). And if a user has a Reputation Point score of equal to or less than -10(negative 10) then they are not allowed to vote on listings meaning they cant cast an Attest or Refute vote on any listing until their reputation point score is more than -10(negative 10). This is to prevent frauds, scammers, and trolls from voting on listings and to promote accountability on their actions. They can however keep writing comments and upvote and downvote on comments as they normally would, its just that they cant vote on listings.

Another crucial thing is listing version control or versioning, let me explain, once a listing is created and it has not received votes then I want the listing to be able to be edited, but once a listing is created and it has received votes I want the listing to be immutable, and once the listing is created it has received votes and the lister has minted it then it's the same as well the listing cannot be edited. Only the user who created the listing can archive it. Now we need to figure out how do we handle the fact that once a listing is created. It has received some votes but the lister hasn't minted it yet. The comments talk about needing more proofs or the listing having wrong details or just needing slight edit, how would we deal with this knowing that once a listing has received votes we don't want the listing to be able to be edited any more, do we implement a simple version control or something else that would allow the listing to be archived. Another new/updated listing to be linked to it, but again the votes wont transfer, users need to cast votes all over again. My rough solution thoughts on this are if the listing needs to be edited once it has received votes but not yet minted then the user can choose to archive(meaning the listing cannot be edited or minted or voted or commented on anymore) the listing and create a new listing that links to the archived listing, and we need to have the archived listing to also contain the new listings link, so basically the archived listing would have a pointer to the new listing and the new listing would have a pointer to the archived listing, and then it's just like a new listing and users can vote and comment on this new listing. Also when a user archives a listing I want the archived listing to be able to have a note attached of which a user can choose to address why it's archived or give reasons, kinda like the same concept of the Vote Comments idea I had. When archiving a listing the user has to choose whether they are simply just archiving it or archiving it and creating a new updated listing on top of it so that we can link the archived and new listing together. I need your help on this versioning concept, do you think this is ok or do you have a better idea or improvement to the idea you would like to suggest, I would welcome it.

And also to clarify, everything would be on-chain and I know you are wondering of the proofs uploads, to clarify the proof uploads would be ipfs uri and external links, so we can keep it all on chain.

Finally, the starting point of this is I have gone to openzepplin contract wizzard and copied the erc721 contract with the options of mintable, auto increment ids, burnable, pausable, enumerable, and uri storage, options enabled.

Structure the Solidity contract to follow modular development best practices. Use detailed Natspec comments for all functions, variables, structs, etc, basically each and every item. Organize the code into well-defined sections such as //STRUCTS, //CONSTANTS, //STORAGE VARIABLES, //CONSTRUCTOR, //CORE FUNCTIONS, //HELPER FUNCTIONS, //VIEWS, //ERROR HANDLING, and //OVERDRIVE FUNCTIONS, arranging them in a logical order. Group functions by type (external, public, internal, private) and clearly separate view/pure functions from state-modifying ones. Ensure the code is easy to read, maintain, and scalable, following Solidity's modular design principles. Include anything else essential for clean organization, readability, and best practices.
